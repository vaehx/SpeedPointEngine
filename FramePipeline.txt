Frame Pipeline:

[Frame::BEGIN] (take frame start timer timestamp = last frame start timestamp, take beginning second timer timestamp)
  --> [Frame::DYNAMICS] (only starts the dynamics pipeline and fires event)
    --> [Dynamics::ANIMATION] (takes time passed for last frame -> calculates keyframe movements)
    --> [Dynamics::PHYSICS] (takes time passed for last frame -> calculates physics movement for differential time element dt)
    --> [Dynamics::INPUT] (only calls the event, passes time passed for last frame as parameter)
    --> [Dynamics::SCRIPT] (takes time passed for last frame -> calculates AI movement, executes user scripts)
  --> [Frame::RENDER] (only starts the deferred rendering pipeline and fires event)
    --> [Render::BEGIN] (Clear current BackBuffer)
    --> [Render::GEOMETRY]
      --> Per Object: (Draw calls / G-Buffer & Stencil buffer creation)
    --> [Render::LIGHTING]
      --> Once (with all light objects passed):  (Coloring & shading)
    --> [Render::POST-FXs] (DOF, MotionBlur, HDR, Color Grading, ...)
      --> 
    --> [Render::END] = [Render::PRESENT] (Swap back- with frontbuffer, nothing more)
[Frame::END] (Increase frame (per second) counter, take end second timer timestamp, calc fLastFrameTime, Check if second has passed, then calc fps and reset frame counter)


---------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------
// This is a partially abstract class and can not be instantiated
// Use specific Renderer Implementations instead
class SRenderPipeline : public SObservedObject
{
public:
	// Default constructor
	SRenderPipeline()
	{
	}

	// Default destructor
	~SRenderPipeline()
	{
		SObservedObject::~SObservedObject();
	}

	// Prepare Backbuffer
	SResult DoBeginRender()	
	{
		SEventParameters params;
		params.Add(...);
		CallEvent(S_E_RENDER_BEGIN, &params);
		params.Clear();

		return Begin();
	}
	virtual SResult Begin();

	// Start the Geometry Section
	SResult DoGeometrySection()
	{
		SEventParameters params;
		params.Add(...);
		CallEvent(S_E_RENDER_GEOMETRY, &params);
		params.Clear();

		
	}
};